//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export module SimilaritySearchClient {

export class Client {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Query all content that has been uploaded to the blob store
     * @param currentPage (optional) 
     * @param pageSize (optional) **Default size:** `10`, `-1` will disable paging
     * @param excludePageCount (optional) `true` will disable row/page counts and may decrease processing time without effecting paging functions
     * @param searchTerm (optional) **Searched Properties:** ContentType; FileName; MetaData
     * @param orderBy_ContentType (optional) 
     * @param orderBy_FileName (optional) 
     * @param orderBy_MetaData (optional) 
     * @return OK
     */
    listGET(currentPage: number | undefined, pageSize: number | undefined, excludePageCount: boolean | undefined, searchTerm: string | null | undefined, orderBy_ContentType: OrderDirections | undefined, orderBy_FileName: OrderDirections | undefined, orderBy_MetaData: OrderDirections | undefined, cancelToken?: CancelToken): Promise<ContentMetaDataReference3> {
        let url_ = this.baseUrl + "/Document/List?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (excludePageCount === null)
            throw new Error("The parameter 'excludePageCount' cannot be null.");
        else if (excludePageCount !== undefined)
            url_ += "excludePageCount=" + encodeURIComponent("" + excludePageCount) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (orderBy_ContentType === null)
            throw new Error("The parameter 'orderBy_ContentType' cannot be null.");
        else if (orderBy_ContentType !== undefined)
            url_ += "orderBy.ContentType=" + encodeURIComponent("" + orderBy_ContentType) + "&";
        if (orderBy_FileName === null)
            throw new Error("The parameter 'orderBy_FileName' cannot be null.");
        else if (orderBy_FileName !== undefined)
            url_ += "orderBy.FileName=" + encodeURIComponent("" + orderBy_FileName) + "&";
        if (orderBy_MetaData === null)
            throw new Error("The parameter 'orderBy_MetaData' cannot be null.");
        else if (orderBy_MetaData !== undefined)
            url_ += "orderBy.MetaData=" + encodeURIComponent("" + orderBy_MetaData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListGET(_response);
        });
    }

    protected processListGET(response: AxiosResponse): Promise<ContentMetaDataReference3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContentMetaDataReference3.fromJS(resultData200);
            return Promise.resolve<ContentMetaDataReference3>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContentMetaDataReference3>(null as any);
    }

    /**
     * Query all content that has been uploaded to the blob store
     * @param body (optional) 
     * @return OK
     */
    listPOST(body: ContentMetaDataReference2 | undefined, cancelToken?: CancelToken): Promise<ContentMetaDataReference3> {
        let url_ = this.baseUrl + "/Document/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListPOST(_response);
        });
    }

    protected processListPOST(response: AxiosResponse): Promise<ContentMetaDataReference3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContentMetaDataReference3.fromJS(resultData200);
            return Promise.resolve<ContentMetaDataReference3>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContentMetaDataReference3>(null as any);
    }

    /**
     * download content from the blob store by file name
     * @param file (optional) 
     * @return OK
     */
    download(file: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Document/Download?";
        if (file === null)
            throw new Error("The parameter 'file' cannot be null.");
        else if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * remove an item from the blob store
     * @param file (optional) 
     * @return OK
     */
    delete(file: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Document/Delete?";
        if (file === null)
            throw new Error("The parameter 'file' cannot be null.");
        else if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * upload new content to the blob store
     * @param file (optional) 
     * @param sourceContentType (optional) 
     * @param overwrite (optional) 
     * @param content (optional) 
     * @return OK
     */
    upload(file: string | undefined, sourceContentType: string | undefined, overwrite: boolean | undefined, content: FileParameter | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Document/Upload?";
        if (file === null)
            throw new Error("The parameter 'file' cannot be null.");
        else if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        if (sourceContentType === null)
            throw new Error("The parameter 'sourceContentType' cannot be null.");
        else if (sourceContentType !== undefined)
            url_ += "sourceContentType=" + encodeURIComponent("" + sourceContentType) + "&";
        if (overwrite === null)
            throw new Error("The parameter 'overwrite' cannot be null.");
        else if (overwrite !== undefined)
            url_ += "overwrite=" + encodeURIComponent("" + overwrite) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (content === null || content === undefined)
            throw new Error("The parameter 'content' cannot be null.");
        else
            content_.append("content", content.data, content.fileName ? content.fileName : "content");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * add additional metadata to the blob store
     * @param body (optional) 
     * @return OK
     */
    store(body: Blob | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Document/Store";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "multipart/form-data",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStore(_response);
        });
    }

    protected processStore(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * list document summaries from the blob store
     * @param currentPage (optional) 
     * @param pageSize (optional) **Default size:** `10`, `-1` will disable paging
     * @param excludePageCount (optional) `true` will disable row/page counts and may decrease processing time without effecting paging functions
     * @param searchTerm (optional) **Searched Properties:** ContentType; FileName; MetaData
     * @param orderBy_ContentType (optional) 
     * @param orderBy_FileName (optional) 
     * @param orderBy_MetaData (optional) 
     * @return OK
     */
    listGET2(currentPage: number | undefined, pageSize: number | undefined, excludePageCount: boolean | undefined, searchTerm: string | null | undefined, orderBy_ContentType: OrderDirections | undefined, orderBy_FileName: OrderDirections | undefined, orderBy_MetaData: OrderDirections | undefined, cancelToken?: CancelToken): Promise<ContentMetaDataReference3> {
        let url_ = this.baseUrl + "/Summaries/List?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (excludePageCount === null)
            throw new Error("The parameter 'excludePageCount' cannot be null.");
        else if (excludePageCount !== undefined)
            url_ += "excludePageCount=" + encodeURIComponent("" + excludePageCount) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (orderBy_ContentType === null)
            throw new Error("The parameter 'orderBy_ContentType' cannot be null.");
        else if (orderBy_ContentType !== undefined)
            url_ += "orderBy.ContentType=" + encodeURIComponent("" + orderBy_ContentType) + "&";
        if (orderBy_FileName === null)
            throw new Error("The parameter 'orderBy_FileName' cannot be null.");
        else if (orderBy_FileName !== undefined)
            url_ += "orderBy.FileName=" + encodeURIComponent("" + orderBy_FileName) + "&";
        if (orderBy_MetaData === null)
            throw new Error("The parameter 'orderBy_MetaData' cannot be null.");
        else if (orderBy_MetaData !== undefined)
            url_ += "orderBy.MetaData=" + encodeURIComponent("" + orderBy_MetaData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListGET2(_response);
        });
    }

    protected processListGET2(response: AxiosResponse): Promise<ContentMetaDataReference3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContentMetaDataReference3.fromJS(resultData200);
            return Promise.resolve<ContentMetaDataReference3>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContentMetaDataReference3>(null as any);
    }

    /**
     * list document summaries from the blob store
     * @param body (optional) 
     * @return OK
     */
    listPOST2(body: ContentMetaDataReference2 | undefined, cancelToken?: CancelToken): Promise<ContentMetaDataReference3> {
        let url_ = this.baseUrl + "/Summaries/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListPOST2(_response);
        });
    }

    protected processListPOST2(response: AxiosResponse): Promise<ContentMetaDataReference3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContentMetaDataReference3.fromJS(resultData200);
            return Promise.resolve<ContentMetaDataReference3>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContentMetaDataReference3>(null as any);
    }

    /**
     * download summary from blob store by file name
     * @param file (optional) 
     * @return OK
     */
    download2(file: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Summaries/Download?";
        if (file === null)
            throw new Error("The parameter 'file' cannot be null.");
        else if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload2(_response);
        });
    }

    protected processDownload2(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * remove summary from blob store
     * @param file (optional) 
     * @return OK
     */
    delete2(file: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Summaries/Delete?";
        if (file === null)
            throw new Error("The parameter 'file' cannot be null.");
        else if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete2(_response);
        });
    }

    protected processDelete2(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * add metadata to entry in blob store
     * @param body (optional) 
     * @return OK
     */
    store2(body: Blob | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/Summaries/Store";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "multipart/form-data",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStore2(_response);
        });
    }

    protected processStore2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * list text contented content from the blob store
     * @param currentPage (optional) 
     * @param pageSize (optional) **Default size:** `10`, `-1` will disable paging
     * @param excludePageCount (optional) `true` will disable row/page counts and may decrease processing time without effecting paging functions
     * @param searchTerm (optional) **Searched Properties:** ContentType; FileName; MetaData
     * @param orderBy_ContentType (optional) 
     * @param orderBy_FileName (optional) 
     * @param orderBy_MetaData (optional) 
     * @return OK
     */
    listGET3(currentPage: number | undefined, pageSize: number | undefined, excludePageCount: boolean | undefined, searchTerm: string | null | undefined, orderBy_ContentType: OrderDirections | undefined, orderBy_FileName: OrderDirections | undefined, orderBy_MetaData: OrderDirections | undefined, cancelToken?: CancelToken): Promise<ContentMetaDataReference3> {
        let url_ = this.baseUrl + "/TextDocument/List?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (excludePageCount === null)
            throw new Error("The parameter 'excludePageCount' cannot be null.");
        else if (excludePageCount !== undefined)
            url_ += "excludePageCount=" + encodeURIComponent("" + excludePageCount) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (orderBy_ContentType === null)
            throw new Error("The parameter 'orderBy_ContentType' cannot be null.");
        else if (orderBy_ContentType !== undefined)
            url_ += "orderBy.ContentType=" + encodeURIComponent("" + orderBy_ContentType) + "&";
        if (orderBy_FileName === null)
            throw new Error("The parameter 'orderBy_FileName' cannot be null.");
        else if (orderBy_FileName !== undefined)
            url_ += "orderBy.FileName=" + encodeURIComponent("" + orderBy_FileName) + "&";
        if (orderBy_MetaData === null)
            throw new Error("The parameter 'orderBy_MetaData' cannot be null.");
        else if (orderBy_MetaData !== undefined)
            url_ += "orderBy.MetaData=" + encodeURIComponent("" + orderBy_MetaData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListGET3(_response);
        });
    }

    protected processListGET3(response: AxiosResponse): Promise<ContentMetaDataReference3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContentMetaDataReference3.fromJS(resultData200);
            return Promise.resolve<ContentMetaDataReference3>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContentMetaDataReference3>(null as any);
    }

    /**
     * list text contented content from the blob store
     * @param body (optional) 
     * @return OK
     */
    listPOST3(body: ContentMetaDataReference2 | undefined, cancelToken?: CancelToken): Promise<ContentMetaDataReference3> {
        let url_ = this.baseUrl + "/TextDocument/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListPOST3(_response);
        });
    }

    protected processListPOST3(response: AxiosResponse): Promise<ContentMetaDataReference3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContentMetaDataReference3.fromJS(resultData200);
            return Promise.resolve<ContentMetaDataReference3>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContentMetaDataReference3>(null as any);
    }

    /**
     * download text content from the blob store
     * @param file (optional) 
     * @return OK
     */
    download3(file: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/TextDocument/Download?";
        if (file === null)
            throw new Error("The parameter 'file' cannot be null.");
        else if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload3(_response);
        });
    }

    protected processDownload3(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * remove text content from the blob store
     * @param file (optional) 
     * @return OK
     */
    delete3(file: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
        let url_ = this.baseUrl + "/TextDocument/Delete?";
        if (file === null)
            throw new Error("The parameter 'file' cannot be null.");
        else if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete3(_response);
        });
    }

    protected processDelete3(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * add metadata to the text content in the blob store
     * @param body (optional) 
     * @return OK
     */
    store3(body: Blob | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/TextDocument/Store";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "multipart/form-data",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStore3(_response);
        });
    }

    protected processStore3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad Request", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * list all vectors in the vector database
     * @return OK
     */
    listAllGET( cancelToken?: CancelToken): Promise<SearchResultModel[]> {
        let url_ = this.baseUrl + "/Vector/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAllGET(_response);
        });
    }

    protected processListAllGET(response: AxiosResponse): Promise<SearchResultModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SearchResultModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SearchResultModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SearchResultModel[]>(null as any);
    }

    /**
     * list all vectors in the vector database
     * @return OK
     */
    listAllPOST( cancelToken?: CancelToken): Promise<SearchResultModel[]> {
        let url_ = this.baseUrl + "/Vector/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAllPOST(_response);
        });
    }

    protected processListAllPOST(response: AxiosResponse): Promise<SearchResultModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SearchResultModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SearchResultModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SearchResultModel[]>(null as any);
    }

    /**
     * find nearest neighbor by vector value
     * @param body (optional) 
     * @return OK
     */
    query(body: number[] | undefined, cancelToken?: CancelToken): Promise<SearchResultModel[]> {
        let url_ = this.baseUrl + "/Vector/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuery(_response);
        });
    }

    protected processQuery(response: AxiosResponse): Promise<SearchResultModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SearchResultModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SearchResultModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SearchResultModel[]>(null as any);
    }

    /**
     * find nearest content in from vector store
     * @param groupBy (optional) suggest "Hash"
     * @param body (optional) 
     * @return OK
     */
    queryGrouped(groupBy: string | undefined, body: number[] | undefined, cancelToken?: CancelToken): Promise<SearchResultModel[]> {
        let url_ = this.baseUrl + "/Vector/QueryGrouped?";
        if (groupBy === null)
            throw new Error("The parameter 'groupBy' cannot be null.");
        else if (groupBy !== undefined)
            url_ += "groupBy=" + encodeURIComponent("" + groupBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQueryGrouped(_response);
        });
    }

    protected processQueryGrouped(response: AxiosResponse): Promise<SearchResultModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SearchResultModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SearchResultModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SearchResultModel[]>(null as any);
    }

    /**
     * perform embedding and lookup neighbors from vector store
     * @param query (optional) 
     * @return OK
     */
    search(query: string | undefined, cancelToken?: CancelToken): Promise<SearchResultModel[]> {
        let url_ = this.baseUrl + "/Vector/Search?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<SearchResultModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SearchResultModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SearchResultModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SearchResultModel[]>(null as any);
    }

    /**
     * perform embedding and lookup neighbors from vector store
     * @param query (optional) 
     * @param groupBy (optional) suggest "Hash"
     * @return OK
     */
    searchGrouped(query: string | undefined, groupBy: string | undefined, cancelToken?: CancelToken): Promise<SearchResultModel[]> {
        let url_ = this.baseUrl + "/Vector/SearchGrouped?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (groupBy === null)
            throw new Error("The parameter 'groupBy' cannot be null.");
        else if (groupBy !== undefined)
            url_ += "groupBy=" + encodeURIComponent("" + groupBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchGrouped(_response);
        });
    }

    protected processSearchGrouped(response: AxiosResponse): Promise<SearchResultModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SearchResultModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SearchResultModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Not Found", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SearchResultModel[]>(null as any);
    }

    health( cancelToken?: CancelToken): Promise<Anonymous> {
        let url_ = this.baseUrl + "/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHealth(_response);
        });
    }

    protected processHealth(response: AxiosResponse): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous.fromJS(resultData200);
            return Promise.resolve<Anonymous>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous>(null as any);
    }
}

export class ContentMetaDataReference implements IContentMetaDataReference {
    contentType!: string | undefined;
    fileName!: string | undefined;
    metaData?: { [key: string]: string; } | undefined;

    constructor(data?: IContentMetaDataReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentType = _data["contentType"];
            this.fileName = _data["fileName"];
            if (_data["metaData"]) {
                this.metaData = {} as any;
                for (let key in _data["metaData"]) {
                    if (_data["metaData"].hasOwnProperty(key))
                        (<any>this.metaData)![key] = _data["metaData"][key];
                }
            }
        }
    }

    static fromJS(data: any): ContentMetaDataReference {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetaDataReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["fileName"] = this.fileName;
        if (this.metaData) {
            data["metaData"] = {};
            for (let key in this.metaData) {
                if (this.metaData.hasOwnProperty(key))
                    (<any>data["metaData"])[key] = (<any>this.metaData)[key];
            }
        }
        return data;
    }
}

export interface IContentMetaDataReference {
    contentType: string | undefined;
    fileName: string | undefined;
    metaData?: { [key: string]: string; } | undefined;
}

export class SearchResultModel implements ISearchResultModel {
    score!: number;
    itemId!: string | undefined;
    metaData?: { [key: string]: any; } | undefined;

    constructor(data?: ISearchResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data["score"];
            this.itemId = _data["itemId"];
            if (_data["metaData"]) {
                this.metaData = {} as any;
                for (let key in _data["metaData"]) {
                    if (_data["metaData"].hasOwnProperty(key))
                        (<any>this.metaData)![key] = _data["metaData"][key];
                }
            }
        }
    }

    static fromJS(data: any): SearchResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        data["itemId"] = this.itemId;
        if (this.metaData) {
            data["metaData"] = {};
            for (let key in this.metaData) {
                if (this.metaData.hasOwnProperty(key))
                    (<any>data["metaData"])[key] = (<any>this.metaData)[key];
            }
        }
        return data;
    }
}

export interface ISearchResultModel {
    score: number;
    itemId: string | undefined;
    metaData?: { [key: string]: any; } | undefined;
}

export class FilterParameter implements IFilterParameter {
    eq?: any | undefined;
    neq?: any | undefined;
    in?: any[] | undefined;
    gt?: any | undefined;
    gte?: any | undefined;
    lt?: any | undefined;
    lte?: any | undefined;

    constructor(data?: IFilterParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eq = _data["eq"];
            this.neq = _data["neq"];
            if (Array.isArray(_data["in"])) {
                this.in = [] as any;
                for (let item of _data["in"])
                    this.in!.push(item);
            }
            this.gt = _data["gt"];
            this.gte = _data["gte"];
            this.lt = _data["lt"];
            this.lte = _data["lte"];
        }
    }

    static fromJS(data: any): FilterParameter {
        data = typeof data === 'object' ? data : {};
        let result = new FilterParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eq"] = this.eq;
        data["neq"] = this.neq;
        if (Array.isArray(this.in)) {
            data["in"] = [];
            for (let item of this.in)
                data["in"].push(item);
        }
        data["gt"] = this.gt;
        data["gte"] = this.gte;
        data["lt"] = this.lt;
        data["lte"] = this.lte;
        return data;
    }
}

export interface IFilterParameter {
    eq?: any | undefined;
    neq?: any | undefined;
    in?: any[] | undefined;
    gt?: any | undefined;
    gte?: any | undefined;
    lt?: any | undefined;
    lte?: any | undefined;
}

export enum OrderDirections {
    Asc = "asc",
    Desc = "desc",
}

export class ContentMetaDataReference2 implements IContentMetaDataReference2 {
    currentPage?: number;
    /** **Default size:** `10`, `-1` will disable paging */
    pageSize?: number;
    /** `true` will disable row/page counts and may decrease processing time without effecting paging functions */
    excludePageCount?: boolean;
    /** **Searched Properties:** ContentType; FileName; MetaData */
    searchTerm?: string | undefined;
    /** **Filterable Properties:** ContentType; FileName; MetaData */
    filter?: Filter | undefined;
    /** **Sortable Properties:** ContentType, FileName, MetaData  **Default Order:**  */
    orderBy?: OrderBy | undefined;

    constructor(data?: IContentMetaDataReference2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.excludePageCount = _data["excludePageCount"];
            this.searchTerm = _data["searchTerm"];
            this.filter = _data["filter"];
            this.orderBy = _data["orderBy"];
        }
    }

    static fromJS(data: any): ContentMetaDataReference2 {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetaDataReference2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["excludePageCount"] = this.excludePageCount;
        data["searchTerm"] = this.searchTerm;
        data["filter"] = this.filter;
        data["orderBy"] = this.orderBy;
        return data;
    }
}

export interface IContentMetaDataReference2 {
    currentPage?: number;
    /** **Default size:** `10`, `-1` will disable paging */
    pageSize?: number;
    /** `true` will disable row/page counts and may decrease processing time without effecting paging functions */
    excludePageCount?: boolean;
    /** **Searched Properties:** ContentType; FileName; MetaData */
    searchTerm?: string | undefined;
    /** **Filterable Properties:** ContentType; FileName; MetaData */
    filter?: Filter | undefined;
    /** **Sortable Properties:** ContentType, FileName, MetaData  **Default Order:**  */
    orderBy?: OrderBy | undefined;
}

export enum MessageLevels {
    Trace = "trace",
    Debug = "debug",
    Info = "info",
    Warning = "warning",
    Error = "error",
    Fatal = "fatal",
    Unknown = "unknown",
}

export class ContentMetaDataReference3 implements IContentMetaDataReference3 {
    readonly rows?: ContentMetaDataReference[] | undefined;
    messages?: ResultMessage[] | undefined;
    readonly currentPage?: number;
    readonly totalPageCount?: number;
    readonly totalRowCount?: number;

    constructor(data?: IContentMetaDataReference3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rows"])) {
                (<any>this).rows = [] as any;
                for (let item of _data["rows"])
                    (<any>this).rows!.push(ContentMetaDataReference.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ResultMessage.fromJS(item));
            }
            (<any>this).currentPage = _data["currentPage"];
            (<any>this).totalPageCount = _data["totalPageCount"];
            (<any>this).totalRowCount = _data["totalRowCount"];
        }
    }

    static fromJS(data: any): ContentMetaDataReference3 {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetaDataReference3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPageCount"] = this.totalPageCount;
        data["totalRowCount"] = this.totalRowCount;
        return data;
    }
}

export interface IContentMetaDataReference3 {
    rows?: ContentMetaDataReference[] | undefined;
    messages?: ResultMessage[] | undefined;
    currentPage?: number;
    totalPageCount?: number;
    totalRowCount?: number;
}

export class ResultMessage implements IResultMessage {
    level?: MessageLevels;
    message!: string | undefined;
    messageCode?: string | undefined;
    context?: string | undefined;
    metaData?: any | undefined;

    constructor(data?: IResultMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.message = _data["message"];
            this.messageCode = _data["messageCode"];
            this.context = _data["context"];
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): ResultMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ResultMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["message"] = this.message;
        data["messageCode"] = this.messageCode;
        data["context"] = this.context;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface IResultMessage {
    level?: MessageLevels;
    message: string | undefined;
    messageCode?: string | undefined;
    context?: string | undefined;
    metaData?: any | undefined;
}

export class Anonymous implements IAnonymous {
    status?: string;
    errors?: any[];

    [key: string]: any;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IAnonymous {
    status?: string;
    errors?: any[];

    [key: string]: any;
}

export class Filter implements IFilter {
    contentType?: FilterParameter;
    fileName?: FilterParameter;
    metaData?: FilterParameter;

    [key: string]: any;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contentType = _data["contentType"] ? FilterParameter.fromJS(_data["contentType"]) : <any>undefined;
            this.fileName = _data["fileName"] ? FilterParameter.fromJS(_data["fileName"]) : <any>undefined;
            this.metaData = _data["metaData"] ? FilterParameter.fromJS(_data["metaData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contentType"] = this.contentType ? this.contentType.toJSON() : <any>undefined;
        data["fileName"] = this.fileName ? this.fileName.toJSON() : <any>undefined;
        data["metaData"] = this.metaData ? this.metaData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFilter {
    contentType?: FilterParameter;
    fileName?: FilterParameter;
    metaData?: FilterParameter;

    [key: string]: any;
}

export class OrderBy implements IOrderBy {
    contentType?: OrderDirections;
    fileName?: OrderDirections;
    metaData?: OrderDirections;

    [key: string]: any;

    constructor(data?: IOrderBy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contentType = _data["contentType"];
            this.fileName = _data["fileName"];
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): OrderBy {
        data = typeof data === 'object' ? data : {};
        let result = new OrderBy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contentType"] = this.contentType;
        data["fileName"] = this.fileName;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface IOrderBy {
    contentType?: OrderDirections;
    fileName?: OrderDirections;
    metaData?: OrderDirections;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

}